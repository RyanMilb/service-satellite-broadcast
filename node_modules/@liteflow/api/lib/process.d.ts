import LCDClient from './util/lcd';
import { IMsg } from './transaction';
import { IValueNullType, IValueStringType, IValueNumberType, IValueBoolType } from './struct';
export declare type IResult = {
    instanceHash: string;
    taskKey: string;
};
export declare type IEvent = {
    instanceHash: string;
    eventKey: string;
};
export declare type ITask = {
    instanceHash: string;
    taskKey: string;
};
export declare type IOutputNullType = {
    type: 'mesg.types.Process_Node_Map_Output_Null_';
    value: {
        null?: 0;
    };
};
export declare type IOutputStringType = {
    type: 'mesg.types.Process_Node_Map_Output_StringConst';
    value: {
        string_const: string;
    };
};
export declare type IOutputDoubleType = {
    type: 'mesg.types.Process_Node_Map_Output_DoubleConst';
    value: {
        double_const: number;
    };
};
export declare type IOutputBoolType = {
    type: 'mesg.types.Process_Node_Map_Output_BoolConst';
    value: {
        bool_const: boolean;
    };
};
export declare type IOutputListType = {
    type: 'mesg.types.Process_Node_Map_Output_List_';
    value: {
        list: {
            outputs: IOutput[];
        };
    };
};
export declare type IOutputMapType = {
    type: 'mesg.types.Process_Node_Map_Output_Map_';
    value: {
        map: IMapOutput[];
    };
};
export declare type IRefSelectorKey = {
    type: "mesg.types.Process_Node_Reference_Path_Key";
    value: {
        key: string;
    };
};
export declare type IRefSelectorIndex = {
    type: "mesg.types.Process_Node_Reference_Path_Index";
    value: {
        index?: string;
    };
};
export declare type IRefPath = {
    path?: IRefPath;
    Selector: IRefSelectorKey | IRefSelectorIndex;
};
export declare type IReference = {
    type: 'mesg.types.Process_Node_Map_Output_Ref';
    value: {
        ref: {
            nodeKey: string;
            path: IRefPath;
        };
    };
};
export declare type IOutput = {
    Value: IOutputNullType | IOutputStringType | IOutputDoubleType | IOutputBoolType | IOutputListType | IOutputMapType | IReference;
};
export declare type IMapOutput = {
    Key: string;
    Value: IOutput;
};
export declare enum FilterPredicate {
    Unknown = 0,
    EQ = 1,
    GT = 2,
    GTE = 3,
    LT = 4,
    LTE = 5,
    CONTAINS = 6
}
export declare const Predicate: {
    EQ: FilterPredicate;
    GT: FilterPredicate;
    GTE: FilterPredicate;
    LT: FilterPredicate;
    LTE: FilterPredicate;
    CONTAINS: FilterPredicate;
};
export declare type IFilterValueNullType = IValueNullType;
export declare type IFilterValueStringType = IValueStringType;
export declare type IFilterValueNumberType = IValueNumberType;
export declare type IFilterValueBoolType = IValueBoolType;
export declare type IFilterCondition = {
    ref: {
        nodeKey: string;
        path: IRefPath;
    };
    predicate: FilterPredicate;
    value: {
        Kind: IFilterValueNullType | IFilterValueStringType | IFilterValueNumberType | IFilterValueBoolType;
    };
};
export declare type IFilter = {
    conditions: IFilterCondition[];
};
export declare type IResultType = {
    type: 'mesg.types.Process_Node_Result_';
    value: {
        result: IResult;
    };
};
export declare type IEventType = {
    type: 'mesg.types.Process_Node_Event_';
    value: {
        event: IEvent;
    };
};
export declare type ITaskType = {
    type: 'mesg.types.Process_Node_Task_';
    value: {
        task: ITask;
    };
};
export declare type IMapType = {
    type: 'mesg.types.Process_Node_Map_';
    value: {
        map: IMapOutput[];
    };
};
export declare type IFilterType = {
    type: 'mesg.types.Process_Node_Filter_';
    value: {
        filter: IFilter;
    };
};
export declare type INode = {
    key: string;
    Type: IEventType | IResultType | ITaskType | IMapType | IFilterType;
};
export declare type IEdge = {
    src: string;
    dst: string;
};
export declare type IDefinition = {
    name: string;
    nodes: INode[];
    edges: IEdge[];
};
export declare type IProcess = IDefinition & {
    hash: string;
    address: string;
};
export declare type IMsgCreate = {
    owner: string;
    name: string;
    nodes: INode[];
    edges: IEdge[];
};
export declare type IMsgDelete = {
    owner: string;
    hash: string;
};
export default class Process extends LCDClient {
    createMsg(owner: string, definition: IDefinition): IMsg<IMsgCreate>;
    deleteMsg(owner: string, hash: string): IMsg<IMsgDelete>;
    get(hash: string): Promise<IProcess>;
    list(): Promise<IProcess[]>;
    exists(hash: string): Promise<boolean>;
    hash(definition: IDefinition): Promise<string>;
}
