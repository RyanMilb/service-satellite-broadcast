"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromValue = (value) => {
    if (!value || !value.type || value.type === 'mesg.types.Value_NullValue')
        return null;
    if (value.type === 'mesg.types.Value_BoolValue')
        return value.value.bool_value || false;
    if (value.type === 'mesg.types.Value_NumberValue')
        return value.value.number_value || 0;
    if (value.type === 'mesg.types.Value_StringValue')
        return value.value.string_value || '';
    if (value.type === 'mesg.types.Value_ListValue')
        return (value.value.list_value.values || []).map(x => exports.fromValue(x.Kind));
    if (value.type === 'mesg.types.Value_StructValue')
        return exports.fromStruct(value.value.struct_value || []);
    throw new Error('not recognized');
};
exports.fromStruct = (object) => {
    if (!object)
        return null;
    return object.reduce((prev, x) => (Object.assign(Object.assign({}, prev), { [x.Key]: exports.fromValue(x.Value.Kind) })), {});
};
exports.toValue = (value) => {
    switch (Object.prototype.toString.call(value)) {
        case '[object Null]':
        case '[object Undefined]':
            return {
                type: "mesg.types.Value_NullValue", value: {}
            };
        case '[object Object]':
            return {
                type: "mesg.types.Value_StructValue",
                value: {
                    struct_value: exports.toStruct(value)
                }
            };
        case '[object Array]':
            return {
                type: "mesg.types.Value_ListValue",
                value: {
                    list_value: {
                        values: value.map((x) => ({ Kind: exports.toValue(x) }))
                    }
                }
            };
        case '[object Number]':
            return {
                type: "mesg.types.Value_NumberValue", value: { number_value: value }
            };
        case '[object Boolean]':
            return {
                type: "mesg.types.Value_BoolValue", value: { bool_value: value }
            };
        case '[object String]':
            return {
                type: "mesg.types.Value_StringValue", value: { string_value: value }
            };
        default:
            throw new Error('not supported');
    }
};
exports.toStruct = (object) => {
    return Object.keys(object).reduce((prev, x) => [
        ...prev,
        {
            Key: x,
            Value: {
                Kind: exports.toValue(object[x])
            }
        }
    ], []).sort((a, b) => a.Key.localeCompare(b.Key));
};
