"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const secp256k1_1 = require("secp256k1");
const sort_object_1 = __importDefault(require("./util/sort-object"));
const account_1 = __importDefault(require("./account"));
class Transaction {
    constructor(stdTx) {
        if (!stdTx.msgs.length)
            throw new Error('you need at least one msg in your transaction');
        this._stdTx = sort_object_1.default(stdTx);
        this.raw = {
            msg: this._stdTx.msgs,
            fee: this._stdTx.fee,
            memo: this._stdTx.memo,
            signatures: []
        };
    }
    static sign(message, ecpairPriv) {
        const hash = crypto_1.createHash('sha256')
            .update(message)
            .digest('hex');
        const buf = Buffer.from(hash, 'hex');
        return secp256k1_1.ecdsaSign(buf, ecpairPriv);
    }
    signWithMnemonic(mnemonic, path) {
        return this.sign(account_1.default.getPrivateKey(mnemonic, path));
    }
    sign(ecpairPriv) {
        const data = JSON.stringify(sort_object_1.default(this._stdTx));
        const { signature } = Transaction.sign(data, ecpairPriv);
        const pubKeyByte = secp256k1_1.publicKeyCreate(ecpairPriv);
        this.raw.signatures.push({
            signature: Buffer.from(signature).toString('base64'),
            pub_key: {
                type: "tendermint/PubKeySecp256k1",
                value: Buffer.from(pubKeyByte).toString('base64')
            }
        });
        return this;
    }
}
exports.default = Transaction;
